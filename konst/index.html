<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Const equivalents of std functions, compile-time comparison, and parsing."><title>konst - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="konst" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0-nightly (c609da59d 2023-04-18)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-1a524efa7bd4ab32.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../konst/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../konst/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate konst</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.2.19</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">konst</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/konst/lib.rs.html#1-422">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Const equivalents of std functions, compile-time comparison, and parsing.</p>
<h2 id="features"><a href="#features">Features</a></h2>
<p>This crate provides:</p>
<ul>
<li>
<p>Const fn equivalents of standard library functions and methods.</p>
</li>
<li>
<p>Compile-time parsing through the <a href="./parsing/struct.Parser.html"><code>Parser</code></a> type, and <a href="macro.parse_any.html"><code>parse_any</code></a> macro.</p>
</li>
<li>
<p>Functions for comparing many standard library types,
with the <a href="./macro.const_eq.html"><code>const_eq</code></a>/<a href="./macro.const_eq_for.html"><code>const_eq_for</code></a>/<a href="./macro.const_cmp.html"><code>const_cmp</code></a>/<a href="./macro.const_cmp_for.html"><code>const_cmp_for</code></a> macros
for more conveniently calling them, powered by the <a href="./polymorphism/index.html"><code>polymorphism</code></a> module.</p>
</li>
</ul>
<h2 id="examples"><a href="#examples">Examples</a></h2><h4 id="parsing-an-enum"><a href="#parsing-an-enum">Parsing an enum</a></h4>
<p>This example demonstrates how you can parse a simple enum from an environment variable,
at compile-time.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>konst::eq_str;
<span class="kw">use </span>konst::{unwrap_opt_or, unwrap_ctx};

<span class="attr">#[derive(Debug, PartialEq)]
</span><span class="kw">enum </span>Direction {
    Forward,
    Backward,
    Left,
    Right,
}

<span class="kw">impl </span>Direction {
    <span class="kw">const fn </span>try_parse(input: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, ParseDirectionError&gt; {
        <span class="comment">// As of Rust 1.51.0, string patterns don&#39;t work in const contexts
        </span><span class="kw">match </span>() {
            <span class="kw">_ if </span>eq_str(input, <span class="string">&quot;forward&quot;</span>) =&gt; <span class="prelude-val">Ok</span>(Direction::Forward),
            <span class="kw">_ if </span>eq_str(input, <span class="string">&quot;backward&quot;</span>) =&gt; <span class="prelude-val">Ok</span>(Direction::Backward),
            <span class="kw">_ if </span>eq_str(input, <span class="string">&quot;left&quot;</span>) =&gt; <span class="prelude-val">Ok</span>(Direction::Left),
            <span class="kw">_ if </span>eq_str(input, <span class="string">&quot;right&quot;</span>) =&gt; <span class="prelude-val">Ok</span>(Direction::Right),
            <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(ParseDirectionError),
        }
    }
}

<span class="kw">const </span>CHOICE: <span class="kw-2">&amp;</span>str = <span class="macro">unwrap_opt_or!</span>(<span class="macro">option_env!</span>(<span class="string">&quot;chosen-direction&quot;</span>), <span class="string">&quot;forward&quot;</span>);

<span class="kw">const </span>DIRECTION: Direction = <span class="macro">unwrap_ctx!</span>(Direction::try_parse(CHOICE));

<span class="kw">fn </span>main() {
    <span class="kw">match </span>DIRECTION {
        Direction::Forward =&gt; <span class="macro">assert_eq!</span>(CHOICE, <span class="string">&quot;forward&quot;</span>),
        Direction::Backward =&gt; <span class="macro">assert_eq!</span>(CHOICE, <span class="string">&quot;backward&quot;</span>),
        Direction::Left =&gt; <span class="macro">assert_eq!</span>(CHOICE, <span class="string">&quot;left&quot;</span>),
        Direction::Right =&gt; <span class="macro">assert_eq!</span>(CHOICE, <span class="string">&quot;right&quot;</span>),
    }
}
</code></pre></div>
<h4 id="parsing-csv"><a href="#parsing-csv">Parsing CSV</a></h4>
<p>This example demonstrates how an CSV environment variable can be parsed into integers.</p>
<p>This requires the <code>&quot;rust_1_64&quot;</code> and <code>&quot;&quot;parsing_no_proc&quot;&quot;</code> features
(the latter is enabled by default).</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>konst::{
    primitive::parse_u64,
    result::unwrap_ctx,
    iter, string,
};

<span class="kw">const </span>CSV: <span class="kw-2">&amp;</span>str = <span class="macro">env!</span>(<span class="string">&quot;NUMBERS&quot;</span>);

<span class="kw">static </span>PARSED: [u64; <span class="number">5</span>] = <span class="macro">iter::collect_const!</span>(u64 =&gt;
    string::split(CSV, <span class="string">&quot;,&quot;</span>),
        map(string::trim),
        map(|s| <span class="macro">unwrap_ctx!</span>(parse_u64(s))),
);

<span class="macro">assert_eq!</span>(PARSED, [<span class="number">3</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>]);
</code></pre></div>
<h4 id="parsing-a-struct"><a href="#parsing-a-struct">Parsing a struct</a></h4>
<p>This example demonstrates how you can use <a href="./parsing/struct.Parser.html"><code>Parser</code></a> to parse a struct at compile-time.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>konst::{
    parsing::{Parser, ParseValueResult},
    for_range, parse_any, try_rebind, unwrap_ctx,
};

<span class="kw">const </span>PARSED: Struct = {
    <span class="comment">// You can also parse strings from environment variables, or from an `include_str!(....)`
    </span><span class="kw">let </span>input = <span class="string">&quot;\
        1000,
        circle,
        red, blue, green, blue,
    &quot;</span>;
     
    <span class="macro">unwrap_ctx!</span>(parse_struct(Parser::from_str(input))).<span class="number">0
</span>};

<span class="kw">fn </span>main(){
    <span class="macro">assert_eq!</span>(
        PARSED,
        Struct{
            amount: <span class="number">1000</span>,
            repeating: Shape::Circle,
            colors: [Color::Red, Color::Blue, Color::Green, Color::Blue],
        }
    );
}

<span class="attr">#[derive(Debug, Clone, PartialEq, Eq)]
</span><span class="kw">pub struct </span>Struct {
    <span class="kw">pub </span>amount: usize,
    <span class="kw">pub </span>repeating: Shape,
    <span class="kw">pub </span>colors: [Color; <span class="number">4</span>],
}

<span class="attr">#[derive(Debug, Clone, PartialEq, Eq)]
</span><span class="kw">pub enum </span>Shape {
    Circle,
    Square,
    Line,
}

<span class="attr">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
</span><span class="kw">pub enum </span>Color {
    Red,
    Blue,
    Green,
}

<span class="kw">pub const fn </span>parse_struct(<span class="kw-2">mut </span>parser: Parser&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; ParseValueResult&lt;<span class="lifetime">&#39;_</span>, Struct&gt; {
    <span class="macro">try_rebind!</span>{(<span class="kw">let </span>amount, parser) = parser.trim_start().parse_usize()}
    <span class="macro">try_rebind!</span>{parser = parser.strip_prefix(<span class="string">&quot;,&quot;</span>)}

    <span class="macro">try_rebind!</span>{(<span class="kw">let </span>repeating, parser) = parse_shape(parser.trim_start())}
    <span class="macro">try_rebind!</span>{parser = parser.strip_prefix(<span class="string">&quot;,&quot;</span>)}

    <span class="macro">try_rebind!</span>{(<span class="kw">let </span>colors, parser) = parse_colors(parser.trim_start())}

    <span class="prelude-val">Ok</span>((Struct{amount, repeating, colors}, parser))
}

<span class="kw">pub const fn </span>parse_shape(<span class="kw-2">mut </span>parser: Parser&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; ParseValueResult&lt;<span class="lifetime">&#39;_</span>, Shape&gt; {
    <span class="kw">let </span>shape = <span class="macro">parse_any!</span>{parser, strip_prefix;
        <span class="string">&quot;circle&quot; </span>=&gt; Shape::Circle,
        <span class="string">&quot;square&quot; </span>=&gt; Shape::Square,
        <span class="string">&quot;line&quot; </span>=&gt; Shape::Line,
        <span class="kw">_ </span>=&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(parser.into_other_error())
    };
    <span class="prelude-val">Ok</span>((shape, parser))
}

<span class="kw">pub const fn </span>parse_colors(<span class="kw-2">mut </span>parser: Parser&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; ParseValueResult&lt;<span class="lifetime">&#39;_</span>, [Color; <span class="number">4</span>]&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>colors = [Color::Red; <span class="number">4</span>];

    <span class="macro">for_range!</span>{i <span class="kw">in </span><span class="number">0</span>..<span class="number">4 </span>=&gt;
        <span class="macro">try_rebind!</span>{(colors[i], parser) = parse_color(parser.trim_start())}
        <span class="macro">try_rebind!</span>{parser = parser.strip_prefix(<span class="string">&quot;,&quot;</span>)}
    }

    <span class="prelude-val">Ok</span>((colors, parser))
}

<span class="kw">pub const fn </span>parse_color(<span class="kw-2">mut </span>parser: Parser&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; ParseValueResult&lt;<span class="lifetime">&#39;_</span>, Color&gt; {
    <span class="kw">let </span>color = <span class="macro">parse_any!</span>{parser, strip_prefix;
        <span class="string">&quot;red&quot; </span>=&gt; Color::Red,
        <span class="string">&quot;blue&quot; </span>=&gt; Color::Blue,
        <span class="string">&quot;green&quot; </span>=&gt; Color::Green,
        <span class="kw">_ </span>=&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(parser.into_other_error())
    };
    <span class="prelude-val">Ok</span>((color, parser))
}


</code></pre></div>
<h2 id="cargo-features"><a href="#cargo-features">Cargo features</a></h2>
<p>These are the features of these crates:</p>
<ul>
<li>
<p><code>&quot;cmp&quot;</code>(enabled by default):
Enables all comparison functions and macros,
the string equality and ordering comparison functions don’t require this feature.</p>
</li>
<li>
<p><code>&quot;parsing&quot;</code>(enabled by default):
Enables the <code>&quot;parsing_no_proc&quot;</code> feature, compiles the <code>konst_proc_macros</code> dependency,
and enables the <a href="macro.parse_any.html"><code>parse_any</code></a> macro.
You can use this feature instead of <code>&quot;parsing_no_proc&quot;</code> if the slightly longer
compile times aren’t a problem.</p>
</li>
<li>
<p><code>&quot;parsing_no_proc&quot;</code>(enabled by default):
Enables the <a href="./parsing/index.html"><code>parsing</code></a> module (for parsing from <code>&amp;str</code> and <code>&amp;[u8]</code>),
the <code>primitive::parse_*</code> functions, <code>try_rebind</code>, and <code>rebind_if_ok</code> macros.</p>
</li>
<li>
<p><code>alloc&quot;</code>:
Enables items that use types from the <a href="https://doc.rust-lang.org/alloc/"><code>alloc</code></a> crate, including <code>Vec</code> and <code>String</code>.</p>
</li>
</ul>
<h4 id="rust-release-related"><a href="#rust-release-related">Rust release related</a></h4>
<p>None of thse features are enabled by default.</p>
<ul>
<li>
<p><code>&quot;rust_1_51&quot;</code>:
Enables items that require const generics,
and impls for arrays to use const generics instead of only supporting small arrays.</p>
</li>
<li>
<p><code>&quot;rust_1_55&quot;</code>: Enables the <code>string::from_utf8</code> function
(the macro works in all versions),
<code>str</code> indexing functions,  and the <code>&quot;rust_1_51&quot;</code> feature.</p>
</li>
<li>
<p><code>&quot;rust_1_56&quot;</code>:
Enables items that internally use raw pointer dereferences or transmutes,
and the <code>&quot;rust_1_55&quot;</code> feature.</p>
</li>
<li>
<p><code>&quot;rust_1_57&quot;</code>: Allows <code>konst</code> to use the <code>panic</code> macro,
and enables the <code>&quot;rust_1_56&quot;</code> feature.</p>
</li>
<li>
<p><code>&quot;rust_1_61&quot;</code>:
Enables const fns that use trait bounds, and the <code>&quot;rust_1_57&quot;</code> feature.</p>
</li>
<li>
<p><code>&quot;rust_1_64&quot;</code>:<br>
Adds slice and string iterators,
string splitting functions(<code>[r]split_once</code>),
const equivalents of iterator methods(in <code>konst::iter</code>),
and makes slicing functions more efficient.
<br>Note that only functions which mention this feature in their documentation are affected.
<br>Enables the <code>&quot;rust_1_61&quot;</code> feature.</p>
</li>
<li>
<p><code>&quot;rust_latest_stable&quot;</code>: enables the latest <code>&quot;rust_1_*&quot;</code> feature.
Only recommendable if you can update the Rust compiler every stable release.</p>
</li>
<li>
<p><code>&quot;mut_refs&quot;</code>(disabled by default):
Enables const functions that take mutable references.
Use this whenever mutable references in const contexts are stabilized.
Also enables the <code>&quot;rust_latest_stable&quot;</code> feature.</p>
</li>
<li>
<p><code>&quot;nightly_mut_refs&quot;</code>(disabled by default):
Enables the <code>&quot;mut_refs&quot;</code> feature. Requires Rust nightly.</p>
</li>
</ul>
<h2 id="no-std-support"><a href="#no-std-support">No-std support</a></h2>
<p><code>konst</code> is <code>#![no_std]</code>, it can be used anywhere Rust can be used.</p>
<h2 id="minimum-supported-rust-version"><a href="#minimum-supported-rust-version">Minimum Supported Rust Version</a></h2>
<p><code>konst</code> requires Rust 1.46.0, because it uses looping an branching in const contexts.</p>
<p>Features that require newer versions of Rust, or the nightly compiler,
need to be explicitly enabled with cargo features.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.cmp_str"><code>pub use crate::string::<a class="fn" href="string/fn.cmp_str.html" title="fn konst::string::cmp_str">cmp_str</a>;</code></div></li><li><div class="item-name" id="reexport.eq_str"><code>pub use crate::string::<a class="fn" href="string/fn.eq_str.html" title="fn konst::string::eq_str">eq_str</a>;</code></div></li><li><div class="item-name" id="reexport.unwrap_ctx"><code>pub use crate::result::<a class="macro" href="result/macro.unwrap_ctx.html" title="macro konst::result::unwrap_ctx">unwrap_ctx</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="array/index.html" title="mod konst::array">array</a></div><div class="desc docblock-short">Const equivalents of array functions.</div></li><li><div class="item-name"><a class="mod" href="iter/index.html" title="mod konst::iter">iter</a></div><div class="desc docblock-short">Const equivalent of iterators with a specific <code>next</code> function signature.</div></li><li><div class="item-name"><a class="mod" href="maybe_uninit/index.html" title="mod konst::maybe_uninit">maybe_uninit</a></div><div class="desc docblock-short">Const fn equivalents of
<a href="https://doc.rust-lang.org/core/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a> methods.</div></li><li><div class="item-name"><a class="mod" href="nonzero/index.html" title="mod konst::nonzero">nonzero</a></div><div class="desc docblock-short"><code>const fn</code> equivalents of <code>NonZero*</code> methods.</div></li><li><div class="item-name"><a class="mod" href="option/index.html" title="mod konst::option">option</a></div><div class="desc docblock-short"><code>const</code> equivalents of <code>Option</code> methods.</div></li><li><div class="item-name"><a class="mod" href="other/index.html" title="mod konst::other">other</a></div><div class="desc docblock-short"><code>const fn</code> equivalents of methods from miscelaneous standard library types.</div></li><li><div class="item-name"><a class="mod" href="primitive/index.html" title="mod konst::primitive">primitive</a></div><div class="desc docblock-short"><code>const fn</code> equivalents of primitive type methods.</div></li><li><div class="item-name"><a class="mod" href="ptr/index.html" title="mod konst::ptr">ptr</a></div><div class="desc docblock-short">Const equivalents of raw pointer and <a href="https://doc.rust-lang.org/nightly/core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull"><code>NonNull</code></a> methods.</div></li><li><div class="item-name"><a class="mod" href="range/index.html" title="mod konst::range">range</a></div><div class="desc docblock-short"><code>const fn</code> equivalents of range methods.</div></li><li><div class="item-name"><a class="mod" href="result/index.html" title="mod konst::result">result</a></div><div class="desc docblock-short"><code>const</code> equivalents of <code>Result</code> methods.</div></li><li><div class="item-name"><a class="mod" href="slice/index.html" title="mod konst::slice">slice</a></div><div class="desc docblock-short"><code>const fn</code> equivalents of slice methods.</div></li><li><div class="item-name"><a class="mod" href="string/index.html" title="mod konst::string">string</a></div><div class="desc docblock-short"><code>const fn</code> equivalents of <code>str</code> methods.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.for_range.html" title="macro konst::for_range">for_range</a></div><div class="desc docblock-short">For loop over a range</div></li><li><div class="item-name"><a class="macro" href="macro.konst.html" title="macro konst::konst">konst</a></div><div class="desc docblock-short">Emulates the <a href="https://doc.rust-lang.org/1.50.0/unstable-book/language-features/inline-const.html">inline const feature</a>, eg: <code>const{ foo() }</code>,</div></li><li><div class="item-name"><a class="macro" href="macro.try_.html" title="macro konst::try_">try_</a></div><div class="desc docblock-short"><code>?</code>-like macro, which allows optionally mapping errors.</div></li><li><div class="item-name"><a class="macro" href="macro.try_opt.html" title="macro konst::try_opt">try_opt</a></div><div class="desc docblock-short"><code>?</code>-like macro for <code>Option</code>s.</div></li><li><div class="item-name"><a class="macro" href="macro.unwrap_opt_or.html" title="macro konst::unwrap_opt_or">unwrap_opt_or</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">For unwrapping <code>Option</code>s in const contexts, with a default value when it’s a <code>None</code>.</div></li><li><div class="item-name"><a class="macro" href="macro.unwrap_res_or.html" title="macro konst::unwrap_res_or">unwrap_res_or</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">For unwrapping <code>Result</code>s in const contexts, with a default value when it’s an error.</div></li></ul></section></div></main></body></html>