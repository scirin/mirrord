<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Encoding data in BER."><title>bcder::guide::encode - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="bcder" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0-nightly (c609da59d 2023-04-18)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../static.files/main-1a524efa7bd4ab32.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../bcder/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../bcder/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module encode</a></h2><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">bcder</a>::<wbr><a href="../index.html">guide</a>::<wbr><a class="mod" href="#">encode</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/bcder/guide/encode.rs.html#1-76">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Encoding data in BER.</p>
<p><em>Note: This guide is still work in progress and will be extended.</em></p>
<p>In many cases, BER requires that a value can state the length of its
encoded content before actually starting to encode this content. Since
this requires duplicate code in many cases, we have decided to use
placeholder objects for encoding. These placeholders, called value
encoders, are available for most built-in types as well as for various
constructions such as tuples, a specific type can produce a
value encoder by manufacturing it from these existing parts.</p>
<p>To return to the example from the decoding guide. It was using this
ASN.1:</p>
<div class="example-wrap"><pre class="language-text"><code>EncapsulatedContentInfo  ::=  SEQUENCE  {
    eContentType ContentType,
    eContent [0] EXPLICIT OCTET STRING OPTIONAL
}

ContentType  ::=  OBJECT IDENTIFIER
</code></pre></div>
<p>The structure was represented by this Rust struct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bcder::{Oid, OctetString};

<span class="kw">pub struct </span>EncapsulatedContentInfo {
    content_type: Oid,
    content: <span class="prelude-ty">Option</span>&lt;OctetString&gt;,
}</code></pre></div>
<p>The value encoders all implement the trait <a href="../../encode/trait.Values.html"><code>encode::Values</code></a> which
represents a sequence of BER-encodable values. The implementation of
our struct could return such an encoder like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bcder::Tag;
<span class="kw">use </span>bcder::encode;

<span class="kw">impl </span>EncapsulatedContentInfo {
    <span class="kw">pub fn </span>encode(<span class="self">self</span>) -&gt; <span class="kw">impl </span>encode::Values {
        <span class="self">self</span>.encode_as(Tag::SEQUENCE)
    }

    <span class="kw">pub fn </span>encode_as(<span class="self">self</span>, tag: Tag) -&gt; <span class="kw">impl </span>encode::Values {
        encode::sequence_as(tag, (
            <span class="self">self</span>.content_type.encode(),
            <span class="self">self</span>.content.map(|s| s.encode())
        ))
    }
}</code></pre></div>
<p>The conventional name for the method produces a value encoder with the
natural tag is <code>encode</code>. If necessary, <code>encode_as</code> should be present to
allow getting a value encoder with a chosen tag for implicit tagging.</p>
<p>The signature of these methods will most likely require a lifetime bound
for the return value as in the example above, if the returned value
contains references to the value or its elements. This is completely fine,
since typically the returned value will only be used to encode the value
right away and then dropped.</p>
</div></details></section></div></main></body></html>