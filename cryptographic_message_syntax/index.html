<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Cryptographic Message Syntax (RFC 5652) in Pure Rust"><title>cryptographic_message_syntax - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="cryptographic_message_syntax" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0-nightly (c609da59d 2023-04-18)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-1a524efa7bd4ab32.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../cryptographic_message_syntax/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../cryptographic_message_syntax/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate cryptographic_message_syntax</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.19.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">cryptographic_message_syntax</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/cryptographic_message_syntax/lib.rs.html#5-1166">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Cryptographic Message Syntax (RFC 5652) in Pure Rust</p>
<p>This crate attempts to implement parts of
<a href="https://tools.ietf.org/rfc/rfc5652.txt">RFC 5652</a> in pure, safe Rust.</p>
<p>Functionality includes:</p>
<ul>
<li>Partial (de)serialization support for ASN.1 data structures. The
Rust structs are all defined. But not everything has (de)serialization
code implemented.</li>
<li>High-level Rust API for extracting useful attributes from a parsed
<code>SignedData</code> structure and performing common operations, such as verifying
signature integrity.</li>
</ul>
<p>RFC 5652 is quite old. If you are looking to digitally sign content, you may
want to look at something newer, such as RPKI (RFC 6488). (RPKI appears to
be the spiritual success to this specification.)</p>
<h2 id="important-security-limitations"><a href="#important-security-limitations">IMPORTANT SECURITY LIMITATIONS</a></h2>
<p><strong>The verification functionality in this crate is purposefully limited
and isn’t sufficient for trusting signed data. You need to include additional
trust verification if you are using this crate for verifying signed data.</strong></p>
<p>This crate exposes functionality to verify signatures and content integrity
of <em>signed data</em>. Specifically it can verify that an embedded cryptographic
signature over some arbitrary/embedded content was issued by a known signing
certificate. This answers the question <em>did certificate X sign content Y</em>.
This is an important question to answer, but it fails to answer other important
questions such as:</p>
<ul>
<li>Is the signature cryptographically strong or weak? Do I trust the signature?</li>
<li>Do I trust the signer?</li>
</ul>
<p>Answering <em>do I trust the signer</em> is an extremely difficult and nuanced
problem. It entails things like:</p>
<ul>
<li>Ensuring the signing certificate is using secure cryptography.</li>
<li>Validating that the signing certificate is one you think it was or was
issued by a trusted party.</li>
<li>Validating the certificate isn’t expired or hasn’t been revoked.</li>
<li>Validating that the certificate contains attributes/extensions desired
(e.g. a certificate can be earmarked as used for signing code).</li>
</ul>
<p>If you are using this crate as part of verifying signed content, you need
to have answers to these hard questions. This will require writing code
beyond what is available in this crate. You ideally want to use existing
libraries for this, as getting this correct is difficult. Ideally you would
consult a security/cryptography domain expert for help.</p>
<h2 id="technical-notes"><a href="#technical-notes">Technical Notes</a></h2>
<p>RFC 5652 is based off PKCS #7 version 1.5 (RFC 2315). So common tools/libraries
for interacting with PKCS #7 may have success parsing this format. For example,
you can use OpenSSL to read the data structures:</p>
<p>$ openssl pkcs7 -inform DER -in <filename> -print
$ openssl pkcs7 -inform PEM -in <filename> -print
$ openssl asn1parse -inform DER -in <filename></p>
<p>RFC 5652 uses BER (not DER) for serialization. There were attempts to use
other, more popular BER/DER/ASN.1 serialization crates. However, we could
only get <code>bcder</code> working. In a similar vein, there are other crates
implementing support for common ASN.1 functionality, such as serializing
X.509 certificates. Again, many of these depend on serializers that don’t
seem to be compatible with BER. So we’ve recursively defined ASN.1 data
structures referenced by RFC5652 and taught them to serialize using <code>bcder</code>.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="asn1/index.html" title="mod cryptographic_message_syntax::asn1">asn1</a></div><div class="desc docblock-short">Holds Rust struct definitions for various ASN.1 primitives. </div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Bytes.html" title="struct cryptographic_message_syntax::Bytes">Bytes</a></div><div class="desc docblock-short">A cheaply cloneable and sliceable chunk of contiguous memory.</div></li><li><div class="item-name"><a class="struct" href="struct.Oid.html" title="struct cryptographic_message_syntax::Oid">Oid</a></div><div class="desc docblock-short">An object identifer.</div></li><li><div class="item-name"><a class="struct" href="struct.SignedAttributes.html" title="struct cryptographic_message_syntax::SignedAttributes">SignedAttributes</a></div><div class="desc docblock-short">Represents the contents of a CMS SignedAttributes structure.</div></li><li><div class="item-name"><a class="struct" href="struct.SignedData.html" title="struct cryptographic_message_syntax::SignedData">SignedData</a></div><div class="desc docblock-short">Represents a CMS SignedData structure.</div></li><li><div class="item-name"><a class="struct" href="struct.SignedDataBuilder.html" title="struct cryptographic_message_syntax::SignedDataBuilder">SignedDataBuilder</a></div><div class="desc docblock-short">Entity for incrementally deriving a SignedData primitive.</div></li><li><div class="item-name"><a class="struct" href="struct.SignerBuilder.html" title="struct cryptographic_message_syntax::SignerBuilder">SignerBuilder</a></div><div class="desc docblock-short">Builder type to construct an entity that will sign some data.</div></li><li><div class="item-name"><a class="struct" href="struct.SignerInfo.html" title="struct cryptographic_message_syntax::SignerInfo">SignerInfo</a></div><div class="desc docblock-short">Represents a CMS SignerInfo structure.</div></li><li><div class="item-name"><a class="struct" href="struct.UnsignedAttributes.html" title="struct cryptographic_message_syntax::UnsignedAttributes">UnsignedAttributes</a></div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.CmsError.html" title="enum cryptographic_message_syntax::CmsError">CmsError</a></div></li><li><div class="item-name"><a class="enum" href="enum.TimeStampError.html" title="enum cryptographic_message_syntax::TimeStampError">TimeStampError</a></div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.time_stamp_message_http.html" title="fn cryptographic_message_syntax::time_stamp_message_http">time_stamp_message_http</a></div><div class="desc docblock-short">Send a Time-Stamp request for a given message to an HTTP URL.</div></li><li><div class="item-name"><a class="fn" href="fn.time_stamp_request_http.html" title="fn cryptographic_message_syntax::time_stamp_request_http">time_stamp_request_http</a></div><div class="desc docblock-short">Send a <a href="asn1/rfc3161/struct.TimeStampReq.html" title="struct cryptographic_message_syntax::asn1::rfc3161::TimeStampReq">TimeStampReq</a> to a server via HTTP.</div></li></ul></section></div></main></body></html>